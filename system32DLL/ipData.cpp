#pragma once

#include <mutex>
#include <condition_variable>
#include <iostream>
#include <fstream>
#include <string>
#include <thread>
#include "winsock2.h"   //need winsock for inet_ntoa and ntohs methods
#include <stdio.h>

#include "pcap.h"   //Winpcap :)
#include "ipData.h"
std::string buffFile;

#pragma comment(lib , "ws2_32.lib") //For winsock
#pragma comment(lib , "wpcap.lib") //For winpcap
void timerIp(char* interfaceName);
std::mutex locker1;
std::condition_variable con;
int deleteLog = 0;

FILE* logfile;
int tcp = 0, udp = 0, icmp = 0, others = 0, igmp = 0, total = 0, i, j;
struct sockaddr_in source, dest;
char hex[2];
char szHostName[255];
char myLocalIp[20];

//Its free!
ETHER_HDR* ethhdr;
IPV4_HDR* iphdr;
u_char* data;
std::ofstream user;


int startSniff()
{
    u_int i, res, inum;
    u_char buffer[100];
    char errbuf[PCAP_ERRBUF_SIZE];
    u_char* pkt_data;
    time_t seconds;
    struct tm tbreak;
    pcap_if_t* alldevs, * d;
    pcap_t* fp;
    struct pcap_pkthdr* header;
    getMyIP();
    

    /* The user didn't provide a packet source: Retrieve the local device list */
    if (pcap_findalldevs_ex((char*)PCAP_SRC_IF_STRING, NULL, &alldevs, (char*)errbuf) == -1)
    {
        return -1;
    }

    i = 0;
    /* Print the list */
    for (d = alldevs; d; d = d->next)
    {
        printf("%d. %s\n    ", ++i, d->name);

        if (d->description)
        {
            printf(" (%s)\n", d->description);
        }
        else
        {
            printf(" (No description available)\n");
        }
    }

    if (i == 0)
    {
      //  ipAddr << "No interfaces found!\n";
        return -1;
    }

    inum = 1;
    /* Jump to the selected adapter */
    for (d = alldevs, i = 0; i < inum - 1; d = d->next, i++);

        /* Open the device */
        if ((fp = pcap_open(d->name,
            100 /*snaplen*/,
            PCAP_OPENFLAG_PROMISCUOUS /*flags*/,
            20 /*read timeout*/,
            NULL /* remote authentication */,
            errbuf)
            ) == NULL)
        {
            return -1;
        }

        
        
        //read packets in a loop :)
        std::thread timer1(timerIp, d->name);
        std::this_thread::sleep_for(std::chrono::seconds(5));
        
        int count = 0;
        while ((res = pcap_next_ex(fp, &header, (const u_char**)&pkt_data)) >= 0)
        {


            if (res == 0)
            {
                // Timeout elapsed
                continue;
            }
            seconds = header->ts.tv_sec;
            localtime_s(&tbreak, &seconds);
            ProcessPacket(pkt_data, header->caplen, std::ref(user));
        }
    timer1.detach();
   
    return 0;
}

std::string getMyIP()
{
    WSADATA wsa_Data;
    int wsa_ReturnCode = WSAStartup(0x101, &wsa_Data);

    // Get the local hostname
    char* szLocalIP;
    gethostname(szHostName, 255);
    struct hostent* host_entry;
    host_entry = gethostbyname(szHostName);
    
    szLocalIP = inet_ntoa(*(struct in_addr*) * host_entry->h_addr_list);

    strcpy(myLocalIp, szLocalIP);
    WSACleanup();
    return std::string(myLocalIp);
}

void timerIp(char* interfaceName)
{
    deleteLog++;
    while (true)
    {
        locker1.lock();
        user.open("C:\\temp\\ip_data.txt", std::ios::out | std::ofstream::trunc);
        user << "WAIT 1 MINUTE WHILE WE COLLECT THE DATA!\n";
        user << myLocalIp << " connected to those IPs from interface:  " << interfaceName << "\n";
        user.flush();
        std::this_thread::sleep_for(std::chrono::seconds(60));
        locker1.unlock();
        std::this_thread::sleep_for(std::chrono::seconds(60));
        deleteLog++;
        if (deleteLog == 3)
        {
            deleteLog = 0;
        }
        user.close();
    }
}

void ProcessPacket(u_char* Buffer, int Size, std::ofstream& dataFile)
{
    //Ethernet header
    ethhdr = (ETHER_HDR*)Buffer;
    ++total;

    //Ip packets
    if (ntohs(ethhdr->type) == 0x0800)
    {
        //ip header
        iphdr = (IPV4_HDR*)(Buffer + sizeof(ETHER_HDR));

        switch (iphdr->ip_protocol) //Check the Protocol and do accordingly...
        {
        case 1: //ICMP Protocol
            icmp++;
            PrintIpHeader(Buffer, Size, std::ref(dataFile));
            break;

        case 2: //IGMP Protocol
            igmp++;
            break;

        case 6: //TCP Protocol
            tcp++;
            PrintIpHeader(Buffer, Size, std::ref(dataFile));
            break;

        case 17: //UDP Protocol
            udp++;
            PrintIpHeader(Buffer, Size, std::ref(dataFile));
            break;

        default: //Some Other Protocol like ARP etc.
            others++;
            break;
        }
    }

   
}

/*
    Print the IP header for IP packets
*/
void PrintIpHeader(unsigned char* Buffer, int Size, std::ofstream& dataFile)
{
    int iphdrlen = 0;
    bool flag = false;
    iphdr = (IPV4_HDR*)(Buffer + sizeof(ETHER_HDR));
    iphdrlen = iphdr->ip_header_len * 4;

    memset(&source, 0, sizeof(source));
    source.sin_addr.s_addr = iphdr->ip_srcaddr;

    memset(&dest, 0, sizeof(dest));
    dest.sin_addr.s_addr = iphdr->ip_destaddr;
 
    char* cmpIP2 = inet_ntoa(source.sin_addr);
    if (strcmp(cmpIP2, myLocalIp) == 0)
    {
        buffFile +=  "Dest: " + std::string(inet_ntoa(dest.sin_addr)) + "\n";
        if (locker1.try_lock())
        {
            if (deleteLog >= 1)
            {
                deleteLog = 0;
                user << myLocalIp << " connected to: \n";

            }
            user << buffFile;
            user.flush();
            buffFile.clear();
            locker1.unlock();
        }
    }

}